<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Sengoku Strategy - Data Driven Ver.</title>
    <style>
        /* --- CSS (本来は style.css) --- */
        :root {
            --bg-color: #f4f1ea;
            --panel-bg: #fff;
            --border-color: #3e3a39;
            --accent-red: #b94047;
            --accent-blue: #2a5caa;
            --accent-green: #37523f;
            --text-color: #333;
        }
        body { font-family: "Yu Mincho", serif; background: var(--bg-color); color: var(--text-color); margin: 0; display: flex; height: 100vh; overflow: hidden; }
        
        /* Layout */
        #sidebar { width: 320px; background: var(--panel-bg); border-right: 2px solid var(--border-color); padding: 15px; display: flex; flex-direction: column; overflow-y: auto; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        #main-area { flex: 1; display: flex; flex-direction: column; padding: 20px; position: relative; }
        
        /* Components */
        .header-bar { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; font-weight: bold; }
        
        .castle-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; overflow-y: auto; padding-bottom: 20px; }
        
        .card { background: var(--panel-bg); border: 1px solid var(--border-color); padding: 15px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); transition: transform 0.2s; }
        .card:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .card-header { display: flex; justify-content: space-between; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-bottom: 10px; }
        .clan-badge { font-size: 0.8em; padding: 2px 6px; color: #fff; border-radius: 3px; }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 4px; }
        .stat-label { color: #666; }
        .bar-wrap { background: #eee; height: 6px; width: 100%; border-radius: 3px; margin: 2px 0 8px 0; overflow: hidden; }
        .bar-val { height: 100%; transition: width 0.5s ease-out; }

        /* Log */
        #log-panel { height: 250px; background: #fff; border-top: 2px solid var(--border-color); overflow-y: auto; padding: 10px; font-family: sans-serif; font-size: 0.85em; }
        .log-line { margin-bottom: 4px; border-bottom: 1px dotted #eee; }
        .log-turn { background: #f0f0f0; font-weight: bold; padding: 4px; margin-top: 10px; }
        .log-war { color: var(--accent-red); }
        .log-alert { color: #d35400; font-weight: bold; }

        /* Controls */
        #controls { margin-top: auto; display: flex; gap: 10px; }
        button { flex: 1; padding: 10px; background: var(--text-color); color: #fff; border: none; cursor: pointer; font-family: inherit; transition: background 0.2s; }
        button:hover { background: #555; }
        button:disabled { background: #ccc; cursor: not-allowed; }

        /* Loading Overlay */
        #loading { position: absolute; inset: 0; background: rgba(255,255,255,0.9); display: flex; justify-content: center; align-items: center; z-index: 999; flex-direction: column; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid var(--text-color); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loading">
    <div class="spinner"></div>
    <div id="loading-text">Loading Game Data...</div>
</div>

<div id="sidebar">
    <h2>戦国シミュレーター</h2>
    <div class="stat-row"><span>年号</span> <strong id="disp-year">---</strong></div>
    <div class="stat-row"><span>季節</span> <strong id="disp-month">---</strong></div>
    <div class="stat-row"><span>手番</span> <span id="disp-turn">待機中</span></div>
    <hr>
    <div id="clan-list"></div>
    <div id="controls">
        <button id="btn-turn" onclick="app.nextTurn()">次へ</button>
        <button id="btn-auto" onclick="app.toggleAuto()">自動進行</button>
    </div>
</div>

<div id="main-area">
    <div class="header-bar">
        <span>全国地図</span>
        <span style="font-size:0.8em; color:#666;">Data-Driven Prototype v1.0</span>
    </div>
    <div id="map-area" class="castle-grid">
        </div>
    <div id="log-panel">
        <div class="log-line">システム起動...</div>
    </div>
</div>

<script>
/**
 * =================================================================
 * 1. 仮想データファイル (VIRTUAL FILE SYSTEM)
 * -----------------------------------------------------------------
 * 本来は server 上にある .json ファイル群です。
 * ここを書き換えるだけで、ゲームバランスやシナリオが変化します。
 * =================================================================
 */

// config.json: ゲーム全体のルール、定数、係数
const FILE_CONFIG = {
    "game": {
        "startYear": 1570,
        "startMonth": 1,
        "maxTurnLoop": 100 // 安全装置
    },
    "economy": {
        "incomeGoldMonth": 3,  // 決算月
        "incomeRiceMonth": 9,  // 収穫月
        "salaryCost": 15,      // 武将一人あたりの給与
        "riceCostPerSoldier": 0.2 // 兵士一人あたりの米消費
    },
    "balance": {
        "commerceRate": 1.2,   // 商業値に対する金銭収入倍率
        "kokudakaRate": 1.5,   // 石高に対する米収入倍率
        "developRate": 0.8,    // 内政値に対する開発効果
        "draftRate": 12,       // 武力に対する徴兵数
        "repairRate": 3.0      // 内政値に対する修復効果
    },
    "war": {
        "maxRounds": 10,
        "dmgStrWeight": 0.8,    // ダメージ計算における武力の重み
        "dmgTroopWeight": 0.05, // ダメージ計算における兵数の重み
        "baseDefense": 100      // 基礎防御力
    }
};

// clans.json: 大名家データ
const FILE_CLANS = [
    { "id": "oda", "name": "織田家", "color": "#b94047", "head": "nobunaga" },
    { "id": "takeda", "name": "武田家", "color": "#2a5caa", "head": "shingen" },
    { "id": "uesugi", "name": "上杉家", "color": "#37523f", "head": "kenshin" }
];

// castles.json: 城データ（初期配置）
const FILE_CASTLES = [
    { "id": "azuchi", "name": "安土城", "owner": "oda", "soldier": 2000, "gold": 1000, "rice": 3000, "kokudaka": 1500, "commerce": 2000, "defense": 300 },
    { "id": "gifu", "name": "岐阜城", "owner": "oda", "soldier": 1500, "gold": 800, "rice": 1500, "kokudaka": 1200, "commerce": 1000, "defense": 200 },
    { "id": "kofu", "name": "躑躅ヶ崎", "owner": "takeda", "soldier": 2500, "gold": 500, "rice": 2500, "kokudaka": 1800, "commerce": 800, "defense": 250 },
    { "id": "takato", "name": "高遠城", "owner": "takeda", "soldier": 1200, "gold": 300, "rice": 1200, "kokudaka": 900, "commerce": 400, "defense": 150 },
    { "id": "kasugayama", "name": "春日山城", "owner": "uesugi", "soldier": 2200, "gold": 600, "rice": 2000, "kokudaka": 1600, "commerce": 1200, "defense": 400 }
];

// officers.json: 武将データ
const FILE_OFFICERS = [
    // 織田
    { "id": "nobunaga", "name": "織田信長", "str": 95, "pol": 100, "int": 96, "loyalty": 100, "clan": "oda", "loc": "azuchi", "role": "lord" },
    { "id": "mitsuhide", "name": "明智光秀", "str": 88, "pol": 96, "int": 98, "loyalty": 70, "clan": "oda", "loc": "azuchi", "role": "vassal" },
    { "id": "katsuie", "name": "柴田勝家", "str": 97, "pol": 65, "int": 55, "loyalty": 95, "clan": "oda", "loc": "gifu", "role": "lord" },
    // 武田
    { "id": "shingen", "name": "武田信玄", "str": 98, "pol": 95, "int": 99, "loyalty": 100, "clan": "takeda", "loc": "kofu", "role": "lord" },
    { "id": "kansuke", "name": "山本勘助", "str": 75, "pol": 80, "int": 97, "loyalty": 100, "clan": "takeda", "loc": "kofu", "role": "vassal" },
    { "id": "masakage", "name": "山県昌景", "str": 94, "pol": 70, "int": 82, "loyalty": 100, "clan": "takeda", "loc": "takato", "role": "lord" },
    // 上杉
    { "id": "kenshin", "name": "上杉謙信", "str": 100, "pol": 75, "int": 92, "loyalty": 100, "clan": "uesugi", "loc": "kasugayama", "role": "lord" },
    { "id": "kanetsugu", "name": "直江兼続", "str": 78, "pol": 95, "int": 94, "loyalty": 98, "clan": "uesugi", "loc": "kasugayama", "role": "vassal" }
];

/**
 * =================================================================
 * 2. データローダー (DATA LOADER)
 * -----------------------------------------------------------------
 * 実際の fetch 通信を模倣(Mock)するクラス。
 * 将来的に本物のサーバー通信に切り替えるときはここだけ直せばOK。
 * =================================================================
 */
class DataLoader {
    static async fetchJson(filename) {
        // ネットワーク遅延を演出
        await new Promise(resolve => setTimeout(resolve, 600));

        // URLルーティングの模倣
        switch(filename) {
            case 'config.json': return FILE_CONFIG;
            case 'clans.json': return FILE_CLANS;
            case 'castles.json': return FILE_CASTLES;
            case 'officers.json': return FILE_OFFICERS;
            default: throw new Error(`404 Not Found: ${filename}`);
        }
    }

    static async loadAll() {
        try {
            const [config, clans, castles, officers] = await Promise.all([
                this.fetchJson('config.json'),
                this.fetchJson('clans.json'),
                this.fetchJson('castles.json'),
                this.fetchJson('officers.json')
            ]);
            return { config, clans, castles, officers };
        } catch (e) {
            console.error(e);
            alert("データ読み込みエラー発生");
        }
    }
}

/**
 * =================================================================
 * 3. ゲームモデル (GAME LOGIC)
 * -----------------------------------------------------------------
 * データを受け取って計算するロジック部分。
 * 数値は一切ハードコードせず、必ず config か parameters を参照する。
 * =================================================================
 */
class GameModel {
    constructor(data) {
        this.config = data.config;
        this.clans = data.clans;
        // データのディープコピー（参照渡し回避）
        this.castles = JSON.parse(JSON.stringify(data.castles));
        this.officers = JSON.parse(JSON.stringify(data.officers));
        
        this.year = this.config.game.startYear;
        this.month = this.config.game.startMonth;
        this.isGameOver = false;
        this.winner = null;
    }

    // --- Helper Methods ---
    getClan(id) { return this.clans.find(c => c.id === id); }
    getCastle(id) { return this.castles.find(c => c.id === id); }
    getOfficersInCastle(castleId) { return this.officers.filter(o => o.loc === castleId && o.clan !== null); }
    getLord(castleId) { return this.officers.find(o => o.loc === castleId && o.role === 'lord'); }

    // --- Turn System ---
    advanceTime() {
        this.month++;
        if (this.month > 12) {
            this.month = 1;
            this.year++;
        }
        this._processResources();
        this._checkBankruptcy();
    }

    // 資源計算：Config係数を全面的に使用
    _processResources() {
        const C = this.config;
        
        this.castles.forEach(castle => {
            const officers = this.getOfficersInCastle(castle.id);
            
            // 収入
            let goldIncome = Math.floor(castle.commerce * C.balance.commerceRate / 12);
            if (this.month === C.economy.incomeGoldMonth) {
                goldIncome += Math.floor(castle.commerce); // ボーナス
            }
            castle.gold += goldIncome;

            let riceIncome = 0;
            if (this.month === C.economy.incomeRiceMonth) {
                riceIncome += Math.floor(castle.kokudaka * C.balance.kokudakaRate);
            }
            castle.rice += riceIncome;

            // 支出
            const salary = officers.length * C.economy.salaryCost;
            castle.gold -= salary;

            const food = Math.floor(castle.soldier * C.economy.riceCostPerSoldier);
            castle.rice -= food;
        });
    }

    _checkBankruptcy() {
        this.castles.forEach(c => {
            // 米不足ペナルティ
            if (c.rice < 0) {
                const deserters = Math.abs(c.rice) * 5;
                c.soldier = Math.max(0, c.soldier - deserters);
                c.rice = 0;
                Logger.log(`${c.name}: 兵糧不足で兵士${deserters}名が逃亡`, 'alert');
            }
            // 金不足ペナルティ
            if (c.gold < 0) {
                c.gold = 0;
                const officers = this.getOfficersInCastle(c.id);
                if (officers.length > 0) {
                    // 忠誠度順にソートして一番低い者が離反
                    officers.sort((a,b) => a.loyalty - b.loyalty);
                    const traitor = officers[0];
                    traitor.clan = null; // 在野へ
                    traitor.loc = null;
                    traitor.role = null;
                    Logger.log(`${c.name}: 資金不足により${traitor.name}が出奔`, 'alert');
                }
            }
        });
    }

    // 勝利判定
    checkWinner() {
        const owners = new Set(this.castles.map(c => c.owner));
        if (owners.size === 1) {
            const winnerId = [...owners][0];
            this.winner = this.getClan(winnerId);
            this.isGameOver = true;
            return true;
        }
        return false;
    }
}

/**
 * =================================================================
 * 4. AIシステム (AI LOGIC)
 * -----------------------------------------------------------------
 * 城ごとに最適な行動をスコアリングして決定する
 * =================================================================
 */
class AI {
    static decideAction(model, castle) {
        const lord = model.getLord(castle.id);
        if (!lord) return { type: 'wait', text: '城主不在' };

        const C = model.config.balance;
        let actions = [];

        // 1. 内政 (Develop)
        const devScore = lord.pol + (100 - castle.commerce/20); // 伸びしろ考慮
        actions.push({ type: 'develop', score: devScore, label: '商業開発' });

        // 2. 徴兵 (Draft)
        let draftScore = lord.str;
        if (castle.soldier < 1000) draftScore += 50; // 兵不足なら優先
        if (castle.gold < 200) draftScore -= 100;    // 金欠なら自重
        actions.push({ type: 'draft', score: draftScore, label: '徴兵' });

        // 3. 戦争 (War)
        const targets = model.castles.filter(c => c.owner !== castle.owner);
        targets.forEach(target => {
            // 簡易勝率計算
            let warScore = (castle.soldier - target.soldier) / 10 + (lord.str - 50);
            if (castle.rice < 1000) warScore -= 50; // 兵糧不安
            
            if (warScore > 20) {
                actions.push({ type: 'war', targetId: target.id, score: warScore + 30, label: `出陣:${target.name}` });
            }
        });

        // スコア降順ソート
        actions.sort((a, b) => b.score - a.score);
        return actions[0];
    }
}

/**
 * =================================================================
 * 5. ビュー (UI / VIEW)
 * -----------------------------------------------------------------
 * 画面描画のみを担当。ロジックは持たない。
 * =================================================================
 */
class View {
    constructor() {
        this.elMap = document.getElementById('map-area');
        this.elLog = document.getElementById('log-panel');
        this.elYear = document.getElementById('disp-year');
        this.elMonth = document.getElementById('disp-month');
        this.elTurn = document.getElementById('disp-turn');
        this.elLoading = document.getElementById('loading');
    }

    hideLoading() { this.elLoading.style.display = 'none'; }

    renderGlobal(model) {
        this.elYear.innerText = model.year;
        this.elMonth.innerText = model.month;
    }

    renderMap(model) {
        this.elMap.innerHTML = '';
        model.castles.forEach(c => {
            const clan = model.getClan(c.owner);
            const lord = model.getLord(c.id);
            const officers = model.getOfficersInCastle(c.id);
            const color = clan ? clan.color : '#999';
            const clanName = clan ? clan.name : '中立';

            const card = document.createElement('div');
            card.className = 'card';
            card.style.borderTop = `5px solid ${color}`;
            
            // 兵数バーの計算
            const soldierPercent = Math.min(100, c.soldier / 30); // 3000でMAX表示

            card.innerHTML = `
                <div class="card-header">
                    <strong>${c.name}</strong>
                    <span class="clan-badge" style="background:${color}">${clanName}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">城主</span>
                    <span>${lord ? lord.name : '<span style="color:red">不在</span>'}</span>
                </div>
                <div class="stat-row"><span class="stat-label">兵力</span> <span>${c.soldier}</span></div>
                <div class="bar-wrap"><div class="bar-val" style="width:${soldierPercent}%; background:${color}"></div></div>
                
                <div class="stat-row"><span class="stat-label">金 / 米</span> <span>${c.gold} / ${c.rice}</span></div>
                <div class="stat-row"><span class="stat-label">石高 / 商業</span> <span>${c.kokudaka} / ${c.commerce}</span></div>
                <div class="stat-row"><span class="stat-label">防御</span> <span>${c.defense}</span></div>
                <div style="text-align:right; font-size:0.8em; color:#888; margin-top:5px;">武将数: ${officers.length}</div>
            `;
            this.elMap.appendChild(card);
        });
    }

    log(text, type = 'normal') {
        const div = document.createElement('div');
        div.className = `log-line log-${type}`;
        div.innerText = text;
        this.elLog.prepend(div);
    }
}

// Global Logger Access
const Logger = {
    _view: null,
    init(view) { this._view = view; },
    log(text, type) { if(this._view) this._view.log(text, type); }
};

/**
 * =================================================================
 * 6. コントローラー (CONTROLLER)
 * -----------------------------------------------------------------
 * ゲームの進行管理。
 * =================================================================
 */
class GameController {
    constructor() {
        this.model = null;
        this.view = new View();
        this.isProcessing = false;
        this.autoMode = false;
        Logger.init(this.view);

        // 初期化プロセス開始
        this.init();
    }

    async init() {
        const data = await DataLoader.loadAll();
        this.model = new GameModel(data);
        this.view.hideLoading();
        this.view.renderGlobal(this.model);
        this.view.renderMap(this.model);
        Logger.log(`データロード完了。${this.model.year}年 開幕。`, 'turn');
    }

    toggleAuto() {
        this.autoMode = !this.autoMode;
        document.getElementById('btn-auto').innerText = this.autoMode ? "自動: ON" : "自動: OFF";
        if (this.autoMode && !this.isProcessing) this.nextTurn();
    }

    async nextTurn() {
        if (this.isProcessing || this.model.isGameOver) return;
        this.isProcessing = true;
        document.getElementById('btn-turn').disabled = true;

        // --- 1. 月初フェイズ ---
        this.model.advanceTime();
        this.view.renderGlobal(this.model);
        Logger.log(`${this.model.year}年 ${this.model.month}月`, 'turn');
        await this.wait(500);

        // --- 2. 各城の行動フェイズ ---
        // ランダム順
        const castleIds = this.model.castles.map(c => c.id).sort(() => Math.random() - 0.5);

        for (const cid of castleIds) {
            const castle = this.model.getCastle(cid);
            // 滅亡判定などで存在しなくなった場合の安全策
            if (!castle) continue;
            
            // 描画更新
            this.view.elTurn.innerText = `${castle.name} 行動中...`;
            this.view.renderMap(this.model); // パラメータ変化の反映

            // AI思考 & 実行
            const action = AI.decideAction(this.model, castle);
            await this.executeAction(castle, action);

            // 勝利判定
            if (this.model.checkWinner()) {
                alert(`天下統一！ 勝者: ${this.model.winner.name}`);
                break;
            }
            await this.wait(300);
        }

        this.view.elTurn.innerText = "待機中";
        this.isProcessing = false;
        document.getElementById('btn-turn').disabled = false;

        if (this.autoMode && !this.model.isGameOver) {
            setTimeout(() => this.nextTurn(), 800);
        }
    }

    async executeAction(castle, action) {
        const lord = this.model.getLord(castle.id);
        const C = this.model.config.balance; // 係数参照
        let msg = `${castle.name} (${lord.name}): `;

        switch(action.type) {
            case 'develop':
                const gain = Math.floor(lord.pol * C.developRate);
                castle.commerce += gain;
                msg += `商業発展 (商+${gain})`;
                break;
            case 'draft':
                const soldiers = Math.floor(lord.str * C.draftRate);
                castle.soldier += soldiers;
                castle.gold -= 50;
                msg += `徴兵 (兵+${soldiers})`;
                break;
            case 'war':
                const target = this.model.getCastle(action.targetId);
                msg += `${target.name}へ侵攻！`;
                Logger.log(msg, 'war');
                await this.resolveWar(castle, target);
                return; // 戦争ログは詳細に出すためreturn
            default:
                msg += "静観";
        }
        Logger.log(msg);
    }

    // 戦争処理（簡易版）
    async resolveWar(atkCastle, defCastle) {
        const atkLord = this.model.getLord(atkCastle.id);
        const defLord = this.model.getLord(defCastle.id); // 不在の可能性あり
        const conf = this.model.config.war;

        let atkTroops = atkCastle.soldier;
        let defTroops = defCastle.soldier;
        let defWall = defCastle.defense;

        // ラウンド処理
        for(let r=1; r<=conf.maxRounds; r++) {
            // 攻撃側のダメージ計算
            // (武力 * 係数) + (兵数 * 係数) + 乱数
            let dmg = (atkLord.str * conf.dmgStrWeight) + (atkTroops * conf.dmgTroopWeight);
            dmg = Math.floor(dmg * (0.8 + Math.random()*0.4)); // 0.8~1.2倍の揺らぎ

            // 防御側被害（兵士と城壁に分散）
            defTroops -= Math.floor(dmg * 0.7);
            defWall -= Math.floor(dmg * 0.1);

            if (defTroops <= 0 || defWall <= 0) break;

            // 反撃（防御側も同様に計算。城主不在なら弱く）
            const defStr = defLord ? defLord.str : 30;
            let counter = (defStr * conf.dmgStrWeight) + (defTroops * conf.dmgTroopWeight);
            counter = Math.floor(counter * (0.8 + Math.random()*0.4));
            
            atkTroops -= counter;
            if (atkTroops <= 0) break;
        }

        // 結果反映
        atkCastle.soldier = Math.max(0, atkTroops);
        defCastle.soldier = Math.max(0, defTroops);
        defCastle.defense = Math.max(0, defWall);

        if (defTroops <= 0 || defWall <= 0) {
            Logger.log(` > ${atkCastle.name}軍の勝利！ ${defCastle.name}を制圧！`, 'war');
            defCastle.owner = atkCastle.owner;
            // 城主解任処理
            const oldLord = this.model.getLord(defCastle.id);
            if (oldLord) oldLord.role = 'vassal';
        } else {
            Logger.log(` > ${defCastle.name}が防衛に成功。`, 'war');
        }
    }

    wait(ms) { return new Promise(r => setTimeout(r, ms)); }
}

// アプリケーション起動
window.app = new GameController();

</script>
</body>
</html>